Ideas on how to improve JIT:
----------------------------


- Register targeting: 

Mainly for function calls: If next use of a register is for
a function call, calcualte value directly into target register. 
	
Issue: Can this lead to premature and unnecessary stores?
	
- Increase cache performance:

Allocate actual storage offsets for registers only after we
have identified, which different values actually need to be persisted.
	
- Read only parameters are copy onto stack:

Alternatives: Move all parameters onto stack, so we can use
direct frame pointer access
Or: Convert function to a method, and have a second pointer
(this->ptr) available for
direct adressing of parameter values.
Or: Implement reference variables (could lead to cascaded
load instructions in inner loops)
	
- Remove stalls in execution pipeline:

Register loads: Have cg_codegen_emit_simple_inst look for
register values that need to/could be
preloaded for following instruction. If those exist, and
registers are available, emit
pre-load instruction before actual instruction to be
scheduled at this point. This will
ensure that data will be available (given it resides in
on-chip cache).
	
Have general instruction scheduling on intermediate code: 
Assuming all data is available, just take instuction
execution cycles and next use into consideration.
	
----------------------------------------------------------------------------

List scheduling for single block:

loop for each segment of the current block
a segments starts after any possible phi instructions and extends until
the first branch instruction

Have set of ready instructions; for each ready instruction, maintain stall if
executed at the current cycle

Initialize ready instructions with set of instructions that do not have any
register in use set that is defined in the current block. Initially, all those
instructions have a stall of 0.

init cycle count to 0

Repeat until (e.g. set of ready instructions is empty):
	Select an instruction with minimum stall from the pool of ready instructions
	--> in case of ties, use an instruction which has minimum impact on register use

	delta = number of stalls + instruction 
	update cycle count adding delta

	for each ready instruction:
		decrease set stall to maximum (old stall - delta, 0)
		if resource conflict with current instruction (e.g. multiplier), increase
			stall to time shared resource is busy

	for each variable in def set of instruction:
		for each instruction in use chain for this variable
			decrease count of pending variables
			if pending variables reaches 0:
				add instruction to ready pool
				initialize stall based on latencies of use variables
