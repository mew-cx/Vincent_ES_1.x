#include "ARBFunctions.h"
#include "Util.h"

#include "ARBNodeHandling.h"

using namespace std;

nodeResult ARBUnaryMathNode(TIntermUnary* node){
	switch(node->getOp()){
		case EOpAbs:{
			nodeResult operand = parseNode(node->getOperand());

			if(operand.fullyParsed){
				ARBVar result = ARBVar::NewTempVar();
				ARBInstructionList list;

				list.append(operand.list);
				list.append(ARBAbsolute(result, operand.var));

				msg() << " Absolute, " << operand.var.tostr() << "\n";
				return nodeResult(result, list);
			}
			else {
				failmsg() << " unhandled function call to abs on line " << node->getLine() << "\n";
				failmsg() << "   operand: " << operand.var.tostr() << " { " << (operand.fullyParsed?"parsed":"not parsed") << " }\n";
				failmsg() << "\n";
				return nodeResult(false);
			}
		}
		case EOpSqrt:{
			nodeResult operand = parseNode(node->getOperand());

			if(operand.fullyParsed){
				ARBVar result = ARBVar::NewTempVar();
				ARBInstructionList list;

				list.append(operand.list);
				list.append(ARBSquareRoot(result, operand.var));

				msg() << " Square root, " << operand.var.tostr() << "\n";
				return nodeResult(result, list);
			}
			else {
				failmsg() << " unhandled function call to sqrt on line " << node->getLine() << "\n";
				failmsg() << "   operand: " << operand.var.tostr() << " { " << (operand.fullyParsed?"parsed":"not parsed") << " }\n";
				failmsg() << "\n";
				return nodeResult(false);
			}
		}
		case EOpNormalize:{
			nodeResult operand = parseNode(node->getOperand());

			if(operand.fullyParsed){
				ARBVar result = ARBVar::NewTempVar();
				ARBInstructionList list;

				list.append(operand.list);

				if(node->getSize() == 3){
					list.append(ARB3ComponentNormalize(result, operand.var));
				}
				else{
					list.append(ARB4ComponentNormalize(result, operand.var));
				}

				msg() << " Normalize, " << operand.var.tostr() << "\n";
				return nodeResult(result, list);
			}
			else {
				failmsg() << " unhandled function call to normalize on line " << node->getLine() << "\n";
				failmsg() << "   operand: " << operand.var.tostr() << " { " << (operand.fullyParsed?"parsed":"not parsed") << " }\n";
				failmsg() << "\n";
				return nodeResult(false);
			}
		}
		default:{
		        failmsg() << "Error in ARBMathNode, uknown operator " << getopname(node->getOp()) << "\n";
				return nodeResult(false);
		}
	}
}

// Handles basic operators +-* e.g. a + b
nodeResult ARBMathNode(TIntermBinary* node) {
	// Generate result variable and instruction list from children
	nodeResult left = parseNode(node->getLeft());
	nodeResult right = parseNode(node->getRight());

	if (left.fullyParsed && right.fullyParsed) {
		ARBVar result = ARBVar::NewTempVar();

		ARBInstructionList list;
		// Include instructions for generating children
		list.append(left.list);
		list.append(right.list);
		// Add instruction for addition

		switch(node->getOp()) {
			case EOpAdd:
				list.append(ARBAddition(result, left.var, right.var));
				break;
			case EOpSub:
				list.append(ARBSubtraction(result, left.var, right.var));
				break;
			case EOpMul:
				list.append(ARBMultiplication(result, left.var, right.var));
				break;
			case EOpVectorTimesScalar: //TODO: implementer
				break;
			default:
				failmsg() << "Error in ARBMathNode, uknown operator " << getopname(node->getOp()) << "\n";
				return nodeResult(false);
				break;
		}

		msg() << " " << getopname(node->getOp()) << ", " << result.tostr() << " = " << left.var.tostr() << " + " << right.var.tostr() << "\n";
		return nodeResult(result, list);
	} else {
		failmsg() << " unhandled " << getopname(node->getOp()) << " , [" << ARBVar::GetNodeVar(node->getLeft()).tostr() << "] + [" << ARBVar::GetNodeVar(node->getRight()).tostr() << "] on line " << node->getLine() << "\n";
		failmsg() << "   left: " << left.var.tostr() << " { " << (left.fullyParsed?"parsed":"not parsed") << " }\n";
		failmsg() << "   right: " << right.var.tostr() << " { " << (right.fullyParsed?"parsed":"not parsed") << " }\n";
		failmsg() << "\n";
		return nodeResult(false);
	}
}

// Handles basic math operations like min, max
nodeResult ARBMathFunctionNode(TIntermAggregate* node) {
	// Generate result variable and instruction list from children

		ARBVar result = ARBVar::NewTempVar();

		//get the parameters
		TIntermSequence& seq = node->getSequence();

		ARBInstructionList list;

		switch(seq.size()){
			case 2: {
				nodeResult param1 = parseNode(seq[0]);
				nodeResult param2 = parseNode(seq[1]);

				if(param1.fullyParsed && param2.fullyParsed){

					if(node->getOp() == EOpMin || node->getOp() == EOpMax){

						TIntermTyped* param2typed = seq[1]->getAsTyped();
						if(param2typed){
							ARBVar var2 = param2.var;

							if (param2typed->getSize() == 1) { // param2 is a float, must be copied to all vector components
								var2 = param2.var.swizzle("x");
							}

							list.append(param1.list);
							list.append(param2.list);

							if(node->getOp() == EOpMin){
								list.append(ARBMinimum(result, param1.var, var2));
							}
							else if(node->getOp() == EOpMax){
								list.append(ARBMaximum(result, param1.var, var2));
							}
							msg() << " " << getopname(node->getOp()) << ", " << param1.var.tostr() << " " << var2.tostr() << "\n";
							return nodeResult(result, list);
						}
					}
					else if(node->getOp() == EOpPow){
						list.append(param1.list);
						list.append(param2.list);
						list.append(ARBPower(result, param1.var, param2.var));

						msg() << " " << getopname(node->getOp()) << ", " << param1.var.tostr() << " " << param2.var.tostr() << "\n";
						return nodeResult(result, list);
					}
					else if(node->getOp() == EOpDot){
						list.append(param1.list);
						list.append(param2.list);

						if(node->getSize() == 3){
							list.append(ARBDot(result, param1.var, param2.var, true));
						}
						else{
							list.append(ARBDot(result, param1.var, param2.var, false));
						}

						msg() << " " << getopname(node->getOp()) << ", " << param1.var.tostr() << " " << param2.var.tostr() << "\n";
						return nodeResult(result, list);
					}
					failmsg() << " unhandled function call " << getopname(node->getOp()) << " on line " << node->getLine() << "\n";
					failmsg() << "   first param: " << param1.var.tostr() << " { " << (param1.fullyParsed?"parsed":"not parsed") << " }\n";
					failmsg() << "   second param: " << param2.var.tostr() << " { " << (param2.fullyParsed?"parsed":"not parsed") << " }\n";
					failmsg() << "\n";
				}
				break;
			}
			default:
                failmsg() << "Error in ARBMathNode, uknown operator " << getopname(node->getOp()) << "\n";
				return nodeResult(false);
		}

		return nodeResult(false);
}

// Handles assignment, i.e. a = b
nodeResult ARBAssignmentNode(TIntermBinary* node) {
	nodeResult left = parseNode(node->getLeft());
	nodeResult right = parseNode(node->getRight());

	if (left.fullyParsed && right.fullyParsed) {
		ARBInstructionList list;

		list.append(left.list);
		list.append(right.list);
		list.append(ARBAssignment(left.var, right.var));

		msg() << " Assignment, " << left.var.tostr() << " = " << right.var.tostr() << "\n";
		return nodeResult(list);
	} else {
		failmsg() << " unhandled assignment, [" << ARBVar::GetNodeVar(node->getLeft()).tostr() << "] = [" << ARBVar::GetNodeVar(node->getRight()).tostr() << "] on line " << node->getLine() << "\n";
		failmsg() << "   left: " << left.var.tostr() << " { " << (left.fullyParsed?"parsed":"not parsed") << " }\n";
		failmsg() << "   right: " << right.var.tostr() << " { " << (right.fullyParsed?"parsed":"not parsed") << " }\n";
		failmsg() << "\n";
		return nodeResult(false);
	}
}

// Handles matrix math operators, e.g. *
nodeResult ARBMatrixMathNode(TIntermBinary* node) {
	switch (node->getOp()) {
		case EOpMatrixTimesVector: {
			ARBVar result = ARBVar::NewTempVar();
			ARBVar matrix = ARBVar::GetNodeVar(node->getLeft());
			nodeResult right = parseNode(node->getRight());

			ARBVar row0 = matrix.getMatrixCol(0);
			ARBVar row1 = matrix.getMatrixCol(1);
			ARBVar row2 = matrix.getMatrixCol(2);
			ARBVar row3 = matrix.getMatrixCol(3);

			ARBInstructionList list;
			list.append(right.list);
			list.append(ARBMatrixTimesVector(result, right.var, row0, row1, row2, row3));

			msg() << "Matrix times vector -> " << result.tostr() << "\n";
			return nodeResult(result, list);
		}
		default:
			failmsg() << "Matrix math operator " << getopname(node->getOp()) << " not handled yet\n\n";
			return nodeResult(false);
	}
}

nodeResult ARBSequenceNode(TIntermAggregate* node) {
	TIntermSequence& seq = node->getSequence();
	if (seq.size()) {
		ARBVar result = ARBVar::None;
		ARBInstructionList list;
		for (int i = 0; i < seq.size(); ++i) {
			nodeResult res = parseNode(seq[i]);
			list.append(res.list);
			result = res.var;
		}
		return nodeResult(result, list);
	} else {
		return nodeResult(ARBInstructionList());
	}
}

nodeResult ARBSwizzleNode(TIntermBinary* node) { //TODO: implementer
	failmsg() << "Swizzling not implemented\n";
	return nodeResult(ARBVar::NewTempVar());
}

nodeResult ARBConstructNode(TIntermAggregate* node) { //TODO: implementer
	failmsg() << "Constructors not implemented\n";
	return nodeResult(ARBVar::NewTempVar());
}
